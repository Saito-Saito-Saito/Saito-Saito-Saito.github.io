<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>これであなたもチェスが作れる　5</title>
    <link rel="stylesheet" href="../stylesheet.css">
</head>
<body>
    <header>
        <div id="title">
            <h1>これであなたも</h1>
            <h1>チェスが作れる</h1>
        </div>
        <ul>
            <li><a href="../index.html">Stage 0&1</a></li>
            <li><a href="../stage2/index.html">Stage 2</a></li>
            <li><a href="../stage3/index.html">Stage 3</a></li>
            <li><a href="../stage4-1/index.html">Stage 4-1</a></li>
            <li><a href="../stage4-2/index.html">Stage 4-2</a></li>
            <li><a href="#">Stage 5</a></li>
            <li><a href="../stage6/index.html">Stage 6</a></li>
            <li><a href="../stage7/index.html">Stage 7</a></li>
            <li><a href="../stage8/index.html">Stage 8</a></li>
            <li><a href="../stage9/index.html">Stage 9</a></li>
        </ul>
    </header>

    <main>
        <section id="s5">
            <h1>Stage 5　勝敗を判定する</h1>
            <p>Stage 4 まででチェスのゲームを作るにあたり、なくてはならない機能はすべて揃いました。これからはよりゲームらしく、より生き生きとしたものを作ります。そこ、「コマンドでやってる時点で殺伐としてるとか」言わない。</p>
        </section>

        <section class="index">
            <h2>目次</h2>
            <p>
                <ul>
                    <li><a href="#s5-1">5-1　キングの位置</a></li>
                    <li><a href="#s5-2">5-2　チェックの数</a></li>
                    <li><a href="#s5-3">5-3　チェックメイト</a></li>
                    <li><a href="#s5-4">5-4　ステイルメイト</a></li>
                </ul>
            </p>
        </section>

        <section id="s5-1">
            <h2>5-1　キングの位置</h2>
            <p><a href="../stage2/index.html#s2-3">2-3</a> で確認しましたが、チェスにおいて勝敗のつき方は 4 通り、キングを取られる・チェックメイト・ステイルメイト・リザインのいずれかでしたね。このうち前 3 つはどれもキングの存在がカギを握っています。またチェックもキングがいてこそです。何せチェックというのは「相手のキングのいるマスへ駒を動かせる状態」ですから。</p>
            <p>そんなわけで Stage 5 においてキングの位置というのはこれ以上ない重要事項です。まあいつも通り簡単にコーディングできますけどね。Board クラスの move メソッド直下に king_place といういかにもな名前のメソッドがあるじゃないですか。そいつを追っていきます。見たまんまです。引数の searcher はキングを探してるプレーヤーの番号です。全部のマス調べ上げてプレーヤーのキングがあればその座標を、キングがどこにもなければ EMPTY をリターンしています。</p>
            <p>このマスの調べ方は少し独特かもしれませんが、リストの構造を考えれば大したことはないでしょう。外側のインデックスが file を、内側のインデックスが rank を表しますから、</p>
            <img src="Kflowchart.png" alt="UNAVAILABLE" width="90%" style="max-width: 350px;">
            <p>
                <ul>
                    <li>すべての file をみる</li>
                    <li>もしリスト board[fil] に searcher のキングがいたら</li>
                    <li>file と board[fil] のキングがいるインデックス (=rank) をリターンする</li>
                </ul>
            </p>
            <p>というアルゴリズムで運用しています。</p>
        </section>

        <section id="s5-2">
            <h2>5-2　チェックの数</h2>
            <p>お次はチェックの判定です。まあ判定と呼ぶくらいですからチェックの有無を True / False でリターンするメソッドかけば事足りるんですが、ダブルチェックとかトリプルチェックという表し方がチェスの棋譜にはありまして、それを見据えて何ヶ所でチェックされているかをリターンする機能が欲しいなと。</p>
            <p>それが checkcounter メソッドです。引数の checkee は</p>
            <p class="stress">チェックを受けている</p>
            <p>プレーヤー番号です。間違えないでください。しっかりわかるようにあえてこの名前をつけたんですから。</p>
            <p>まずは checkee のキングを探します。motionjudge に通して相手の駒がたどり着けるか検証するという意図ももちろんありますけれども、そもそもキングがいなければ相手はチェックのしようがないので「キングがいるか」も同時に見ています。もしキングがいない (king_place が EMPTY) であれば TO の型は list ではなく int になりますから、try 文の中でエラーを起こして except へ入り False をリターンする仕組みになっています。</p>
            <p>キングがいる場合は try 文内で toFILE, toRANK にキングの座標を入れ、for 文によって盤面上すべての相手の駒の座標を frFILE, frRANK の中に入れ motionjudge を実行します。もし motionjudge が True をリターンすればチェックしていることになりますから、カウンター count の値を増やしてあげましょう。</p>
            <p>ループを抜けたら count をリターンします。つまりチェックされている回数が返されます。もしチェックされていなければ</p>
            <p class="stress">リターンは 0</p>
            <p>です。False ではないことに注意してください。</p>
        </section>

        <section id="s5-3">
            <h2>5-3　チェックメイト</h2>
            <p>「できればチェックメイトで勝ちたい。あわよくば『チェックメイトです!!』と言わせてみたい」チェスのゲームをやる人はみんなこういう頭をしています。その期待に応えてあげるのがゲームデザイナーの役目じゃないですか。応えてあげましょうよ。ということでチェックメイトを判別する機能をこしらえます。それが Board クラスの checkmatejudge メソッドになります。引数の matee はチェックメイト</p>
            <p class="stress">される側</p>
            <p>のプレーヤーです。お間違えなきよう。</p>
            <p>チェックメイトというのは「すでにチェックされていて、どの駒をどのように動かしてもチェックを逃れられない」状況ですよね。ですからメソッドの一番上ではチェックされていない状況に対して False をリターンしています。</p>
            <p>ここから先のフローチャートを先に上げておきます。確認してください。こんなものまで用意してる私って結構良心的でしょ。あ、また傲慢なこと言った。</p>
            <img src="cmfloatchart.png" alt="UNAVAILABLE" width="90%" style="max-width: 400px;">
            <p>4 重の for ループは「matee のすべての駒の正しい動かし方」をシラミつぶしに見ていることを意味します。まず外側の 2 つで移動元となるマスをおさえます。それが matee の駒であれば、次の 2 重 for ループで駒の移動先をシラミつぶしに探します。</p>
            <p>さて、移動元と移動先の候補が出揃いました。プログラムする人間の心理としては、「現状の self から駒を動かしてチェックを回避できるか見てみたい」と思っています。ですが一度駒を動かしてしまうと再び元の状態に戻せない以上、この Board のインスタンス(クラスのオブジェクト)に手をつけて駒を動かすのは禁忌です。言い換えると、このループの内側では</p>
            <p>
                <ul>
                    <li>self を完璧に再現して駒を動かしてみたい</li>
                    <li>self 自体を触ることは許されない</li>
                </ul>
            </p>
            <p>というジレンマを抱えています。そこで local_board という、self を完コピした、まったく新しいインスタンス作ります。「モノホンが傷つくといけないから影武者に危険地帯を歩かせる」といったところでしょうか。</p>
            <p>実際、local_board を宣言したあとに local_board.move を発動して駒を動かします。当然のことながら移動元と移動先は for ループのパラメーターどおりです。ここで local_board について、</p>
            <p>
                <ul>
                    <li>move から True (移動成功)</li>
                    <li>checkcounter から 0 (チェックされていない)</li>
                </ul>
            </p>
            <p>が得られれば「移動してチェックを回避できる」という意味になりますから、チェックメイトではないということになります。False をリターンしてください。</p>
            <p>一方でループを抜けきってしまいますと、「どのように動かしてもチェックを免れることはできない」ということになってしまいますので、「チェックメイト」を表す True をリターンしましょう。</p>
        </section>

        <section id="s5-4">
            <h2>5-4　ステイルメイト</h2>
            <p>決着のつき方その 3, ステイルメイトです。stalematejudge メソッドで判別します。相変わらず引数の matee は「ステイルメイトされる側」つまり動けなくなってしまったか確認したい方のプレーヤー番号です。もう強調しなくていいでしょ？しましょうか？</p>
            <p class="stress">される側</p>
            <p>もう大丈夫ですね。</p>
            <p>やることはほぼほぼチェックメイトと変わりません。唯一の違いは、「現状でチェックを受けていない」ことです。メソッドの先頭ではそれを調べています。もし checkcounter が 0 でも False でもなければそれは間違いなくチェックされている状況ですから、ステイルメイトとは言えません。</p>
            <p>この第一関門を突破したものだけが次なるステップへ進むことができます。4 重の for ループです。そう、<a href="#s5-3">5-3</a> のチェックメイトとまったく同じことをします。コピペでいいですよ、コピペで。え？「てめーのコードじゃ書いてることチゲー」って？気のせいですよ。ほんとに気のせいです。いや、マジで。嘘だと思うならコピペして動かしてみなさいって。</p>
        </section>

        <section>
            <h2>次回予告</h2>
            <p>さあ、勝敗の判定がつきました。一応ご自分のコードがしっかり作動するかテストしてみてください。あんまり後になってバグると「このクソ長いコードからバグ見つけんのかよ」と絶望に打ちひしがれることになりますので、ぜひ今のうちに。あの絶望は何度やってもダメですね。ろくなもんじゃない</p>
            <p>次回はプレーヤーの入力をあつかっていきます。<a href="../stage2/index.html#s2-2">2-2</a> で決めたように、このゲームはプレーヤーに棋譜の書き方で駒を動かしてもらいます。今一度書き方を復習しておいてください。次回はこの棋譜の書き方から盤面を動かせるようにします。</p>
            <p>加えて文字列操作と正規表現も使います。まあ正規表現は知らないと何もできないかと言われるとそうでもないんですが、非常に便利なテクニックですからこの際使いこなせるようになっておいたらいいんじゃないですか。</p>
            <p><a href="../stage6/index.html">次回　Stage 6　入力を変換する</a></p>
        </section>
    </main>
    
    <footer>
        <ul>
            <li>LAST EDITED: 2020/5/2</li>
            <li>
                <a href="https://github.com/Saito-Saito-Saito" target="_blank">このページの作成者のGitHub</a>
            </li>
            <li>
                <a href="https://twitter.com/zsops_n" target="_blank">このページの作成者のTwitter</a>
            </li>
            <li>
                <a href="#">トップに戻る</a>
            </li>
        </ul>
    </footer>
</body>
</html>