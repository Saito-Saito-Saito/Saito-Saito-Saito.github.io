<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stage 4-1</title>
    <link rel="stylesheet" href="../stylesheet.css">
</head>
<body>
    <header>
        <div id="title">
            <h1>これであなたも</h1>
            <h1>チェスが作れる</h1>
        </div>
        <ul>
            <li><a href="../index.html">Stage 0&1</a></li>
            <li><a href="../stage2/index.html">Stage 2</a></li>
            <li><a href="../stage3/index.html">Stage 3</a></li>
            <li><a href="#s4">Stage 4-1</a></li>
        </ul>
    </header>

    <main>
        <section id="s4">
            <h1>Stage 4-1　駒をうごかす〜判定編〜</h1>
            <p>さあ、やっとチェスっぽくなってきましたね。今回使うファイルは board.py だけです。しかもすべて Board クラスの中だけです。なんでこんなにクラスでっかくするんだって思うかもしれませんが、ゲームをデザインしたときその威力に気づくことになるでしょう。</p>
        </section>

        <section class="index">
            <h2>目次</h2>
            <ul>
                <li><a href="#s4-1-1">4-1-1　前段階</a></li>
                <li><a href="#s4-1-2">4-1-2　ポーン</a></li>
                <li><a href="#s4-1-3">4-1-3　ルーク</a></li>
                <li><a href="#s4-1-4">4-1-4　ナイト</a></li>
                <li><a href="#s4-1-5">4-1-5　ビショップ</a></li>
                <li><a href="#s4-1-6">4-1-6　クイーン</a></li>
                <li><a href="#s4-1-7">4-1-7　キング</a></li>
                <li><a href="#s4-1-8">4-1-8　途中の駒の除外</a></li>
            </ul>
        </section>

        <section id="s4-1-1">
            <h2>4-1-1　前段階</h2>
            <p>BOARDprint 直下に、その名のとおり motionjudge というメソッドがありますよね。これで「駒が正しい動きをしているか」を判定しています。正しければ True を、間違っていれば False を返します。引数は</p>
            <ul>
                <li><code>frFILE</code>　→　元のfile</li>
                <li><code>frRANK</code>　→　元のrank</li>
                <li><code>toFILE</code>　→　先のfile</li>
                <li><code>toRANK</code>　→　先のrank</li>
                <li><code>promote</code> →　プロモーションで成り上がる駒の種類（駒番号）</li>
            </ul>
            <p>を表しています。元と先の座標およびプロモーションの情報ですね。 motionjudge 関数だけでなく、ありとあらゆる場面でこの形をガンガン使いますので、今のうちに慣れていってください。from と to と考えれば難しいことはないと思いますが。</p>
            <p>最初の if 文は「座標がちゃんと盤面の中におさまっているか」を判定しています。8マス×8マスの盤面のインデックスに15とか入ったらマズいでしょ。ここで引っかかったらどう考えても間違った動きなので False をリターンします。</p>
            <p>次に動かそうとしているプレーヤーはだれか、その駒の種類は何かを取得しておきます。</p>
            <p>次の if は「自分の駒が置いてる場所に動かそうとした」場合です。当然それはアウトですから、 False を返します。</p>
            <p>今度は動かそうとしているマス ([frFILE][frRANK]) に何も置いていない場合です。当然動かすものがないんですから、 False を返さなければいけません。</p>
            <p>ここまででとりあえず「駒の動きを見るまでもなく」アウトな動かし方をひととおり排除できました。次は1種類ずつ駒の動きを確認していきます。</p>
        </section>

        <section id="s4-1-2">
            <h2>4-1-2　ポーン</h2>
            <p>ポーンは実に多彩な動きをみせてくれます。しかも白黒あわせて16個もありますからね、戦いにおいてもかなり重要な駒になるわけですよ。ええ、ですから、基本の動きに加えて例外などなどルールの量がめちゃめちゃ多い。全く無駄なもんばっか作りおって。ということで、ルール自体は他のサイトさんに任せるとして、我々はさっさとコーディング進めてしまいましょう。</p>
            <p>まず基本となる動きです。ポーンは様々ルールがあれど、やはりいちばんよく使うのは「一歩前進」ですね。この条件は</p>
            <p>
                <ul>
                    <li>横に動かない</li>
                    <li>盤面の外に出ない</li>
                    <li>前のマスにどの駒も置かれていない</li>
                </ul>
            </p>
            <p>でした。そして、いちばん相手側、盤面の端まで来たら必ずくいーん・ルーク・ナイト・ビショップのいずれかにプロモーションしなければいけません。ということで、これを早速コーディングしていきます。</p>
            <p>ポーンの場合の最上部の if 文は「端についたのにプロモーションしてないやつをしょっぴく」という意味です。プレーヤーの色で場合分けする必要はありません。白は第１ rank に、黒は第８ rank にポーンを置くことがありませんから。</p>
            <p>次が基本動作です。ここで True を返す条件は、</p>
            <p>
                <ul>
                    <li>file が同じ</li>
                    <li>rank の移動が適切</li>
                    <li>先に何もない</li>
                </ul>
            </p>
            <p>です。ここで特に疑問が湧くかもしれません。「なんで rank の差をとって player と比較してんだ？」実はこれ、ちょっとチートっぽい計算なんですよ。白の場合で考えてみましょう。白がポーンを進めるとき、 rank の番号が１つ増えますから、toRANK - frRANK = 1 となります。一方で、config.py で WHITE = 1 と定義していますよね。だからこのように rank の移動が適切か確かめています。黒の場合は rank の番号が１つ減りますし BLACK = -1 と定義しているので、同じように確認が取れます。</p>
            <p>次の elif 文は「相手の駒をとる通常の場合」について確かめています。True を返す条件は、</p>
            <p><ul>
                <li>ひとつ隣の file</li>
                <li>（各方からみて）ひとつ前の rank</li>
            </ul></p>
            <p>です。ひとつ隣とは file の差が 1 か -1 かであることを意味しますから、絶対値を取れば両方 1 として処理できますね。</p>
            <p>次いで最初の 2 マス移動です。初めて動かすポーンにかぎり発動するこの条件ですが、つまりは白なら第２ rank, 黒なら第７ rank にあるポーンを動かした時のみ player * 2 だけ rank が変化するという意味です。これはプロモーションチェックとは違ってプレーヤーの色で場合分けが必要になりますよ。端からひとつ前はどちらのポーンもいる可能性があるので。それともうひとつ、移動先だけでなく通過するマスにもほかの駒があってはいけないことも忘れてはいけません。</p>
            <p>そして最後に厄介なアンパッサンが残っています。なんでこんなルール作りおったんでしょうね。まったく</p>
            <p class="stress">余計なことしてくれやがって</p>
            <p>アンパッサンの条件をもう一度確認しましょう。</p>
            <p>
                <ul>
                    <li>相手がポーンを２マス動かした直後に</li>
                    <li>相手から見てそのポーンの手前のマスに</li>
                    <li>どの駒も置かれていないとき</li>
                    <li>そのマスに</li>
                    <li>そのポーンのすぐ隣にある自分のポーンを動かして</li>
                    <li>相手のポーンをとることができる</li>
                </ul>
            </p>
            <p>とてつもないルールですよね。これコード見た方がわかるんじゃねえかっていう。さて、ここまで解説した中では検証できないルールがひとつあって、それが「相手が２マスポーンを動かした直後」ってとこですよね。それに相手がポーンを動かした後、それ以外のポーンではアンパッサンできないので、どれが「その」ポーンか記録しておかなければいけませんね。</p>
            <p>そこで一度 Board の初期関数に戻りましょうか。 board を定義した直後に self.ep_target ってのがあるでしょう。これに記録してくんです。何をって、相手が２マス動かしたポーンの座標に決まってるじゃないですか。例えば黒が d7 から d5 にポーンを動かしたら ep_target = [d - 1, 5 - 1] って記録しとくんです。２マス動かさなかったら？いいとこ気がつきましたね。みなさま、お待たせいたしました。config.py で OVERSIZE ってのを定義したじゃないですか。あれを使う時が来たんですよ。このアホみたいにバカでかい数をあえて使うことで、「これってもしかしてバグるんじゃないかな」という不安を一切許さない、とても読みやすいコードに仕上がるわけです。その証拠に初期関数の引数でデフォルトが設定してあるでしょう？ input_target=[OVERSIZE, OVERSIZE] って。基本的にこのオーバーなリストを使うですが、たまにポーンを２マス前に進めた時は ep_target をご覧あれ、という仕組みなんです。ではコーディングに移りましょう。2 マス動かした直後のポーンの座標が ep_target なわけですから、アンパッサンで True を返す条件は、</p>
            <p>
                <ul>
                    <li>ep_target のとなりに fr</li>
                    <li>ep_target の奥（rank が frRANK + player）に to</li>
                    <li>to が EMPTY</li>
                </ul>
            </p>
            <p>ですね。それをコードにするとご覧のようなものになります。</p>
            <p>さあ、これでポーンは全て終わりました。自称ポーンでほかの動きしてるのは全て False にしてしまいましょう。長かったですね。これがあと５種類も続くと考えると気が遠くなりそうですが、ご安心ください。こんなに面倒なのはポーンが最後（のはず）です。ここを乗り切った皆さんなら必ずすべての駒についてコーディング達成できます。</p>
        </section>
        
        <section id="s4-1-3">
            <h2>4-1-3　ルーク</h2>
            <p>みなさん、ルークです。こいつについては「正しい動きについて True を返す」ポーン作戦より、「間違った動きに False を突きつける」戦法がいいでしょう。なぜそんなこというかって？コード見てみましょうか。</p>
            <p>まず第一に、タテヨコバビューン（１マスもバビューン）と動いていない場合、要はナナメに動いている場合は何がなんでも False ですな。</p>
            <p>ところで、ここで False が突きつけられなかった場合でも、すべて True とはできません。駒を飛び越えることができませんから。ただ、ビショップやクイーンでも同じことを考えないといけませんから、後回しにしておきましょう。</p>
        </section>

        <section id="s4-1-4">
            <h2>4-1-4　ナイト</h2>
            <p>ナイトほど変な動きをする駒はありません。これはコーディングが難しそうだと思うのも無理ありません。ですが、 file と rank を考えてみるとそう難しいことでもありません。True を返す条件は、</p>
            <p><ul>
                <li>rank の差が 1, file の差が 2</li>
                <li>rank の差が 2, file の差が 1</li>
            </ul></p>
            <p>のいずれかであることがわかるかと思います。これ以外はすべからく False です。</p>
        </section>

        <section id="s4-1-5">
            <h2>4-1-5　ビショップ</h2>
            <p>ビショップはルークと同じように考えればいいでしょう。ナナメは「file が 1 増えれば rank は 1 減る」「file が 1 減ると rank が 1 減る」といった具合に表せますので、 True を返す条件は「file の差と rank の差が等しい」と表せます。駒を飛び越える場合の処理はルークと一緒にあとでやりましょう。</p>
        </section>

        <section id="s4-1-6">
            <h2>4-1-6　クイーン</h2>
            <p>クイーンで許されない動きはルークでもビショップでも許されません。これを念頭にコーディングして、駒を飛び越える場合をあとで処理すれば問題ありません。</p>
        </section>

        <section id="s4-1-7">
            <h2>4-1-7　キング</h2>
            <p>「キングなんてタテヨコナナメに１マスしか動かねーんだから書くことねーだろ」って思ってます？困りますねえ。いや、半分はあたりなんですけど。ではその半分を先に片付けてしまいましょう。</p>
            <p>要は file と rank の差が 1 以下であればいいんです。「以下」ですよ「以下」これがないとナナメしかいけませんから。つまり、タテに進むとき file の差は 0 じゃないですか。なので</p>
            <pre>
                <code>
if abs(...) &lt;= 1 ...
    return True
                </code>
            </pre>
            <p>とかけます。</p>
            <p>さて、簡単な方が終わりましたから厄介者をどうにかしましょう。何すんだって？キャスリングですよ。こいつは基本的にキングの動きとて扱うのがいちばん楽ですからね。ルークだと「ルーク動かしたくないのに」ってなったりして面倒ですから。キャスリングの条件をもう一度確認してみましょうか。</p>
            <p>
                <ul>
                    <li>キングと動かすルークを一度も動かしたことがない</li>
                    <li>キングと動かすルークの間に何もない</li>
                    <li>移動前後、移動中にキングがチェックされない</li>
                </ul>
            </p>
            <p>いやいや、面倒ですね。私もこれ書いてる間に自分のコードがこれ全部満たしてないことに気がついて慌てたくらいですよ。</p>
            <p>まず、キングの普通の動きを確認した後に rank という新しい変数を設定していますね。これはあとで条件分岐するときに大いに威力を発揮します。</p>
            <p>次に出てくる条件文の中に初出の変数があると思います。castl_q です。ではこれを定義している初期関数にとんでみましょう。</p>
            <p>self.castl_q, self.castl_k はそれぞれクイーンサイド、キングサイドにキャスリングできるプレーヤー番号を格納するリストです。初期値では初期関数の引数にあるとおり両プレーヤーを格納します。定義の際に copy.deepcopy という関数を使っているのは、新しくリストを作成するためです。仮にこの作業を怠って <code>self.castl_k = input_k</code> としたとしましょう。このとき、デフォルトを使用するなら問題ありませんけれども、初期化の際に何かリストを代入したとしましょう。パイソンにおいて、代入というのは基本的に変数の値ではなく変数を格納しているコンピューター上の部屋の番号（参照）を渡しているんです。正確にいうと、「ミュータブルの変数は参照を渡し、イミュータブルの変数は値を渡す」という言い方をするんですが。例えば int 型や str 型はイミュータブルなので深いこと考えずに何でもかんでもつっこみゃいいんですが、リストとなるとそうはいかないんですね。リストの場合、代入はすべて参照渡しです。なので、例えば L = [WHITE, BLACK] というリストを新しく M というリストに代入した場合、M に操作を加えて、例えば WHITE を削除したら、L でも WHITE が削除されてしまうんですわ、これが。じゃあ L の中身は残しておきたいと思ったときどうすればいいか。そのとき使うのが copy.deepcopy です。まあ１じげんリストなら copy.copy でもいいんですが、こっちさえ覚えとけばってのは deepcopy の方ですね。これを使って <code>M = copy.deepcopy(L)</code> をやっといて M をいじっても、 L にはなんの支障もありません。ね、便利でしょ。</p>
            <p>キャスリングに戻りましょう。キャスリングにはキングサイドとクイーンサイドがあります。文字通りキングサイドはキング側のルークと、クイーンサイドはクイーン側のルークとキャスリングします。私のコードではまずクイーンサイドを確認していますね。クイーンサイドのキャスリングをする条件は、</p>
            <p>
                <ul>
                    <li>player が castl_q にいる</li>
                    <li>キングの行先が [c - 1][rank]</li>
                    <li>[b - 1][rank], [c - 1][rank], [d - 1][rank] がすべて EMPTY</li>
                    <li>[c - 1][rank], [d - 1][rank], [e - 1][rank] に相手の駒がこない</li>
                </ul>
            </p>
            <p>の４つです。こと４つ目はちょいと if 文内で片付けるには複雑ですから、先に前３つで条件を確認しています。</p>
            <p>3 つの条件を突破したものにかぎり４つ目の条件の確認に取り掛かります。４つ目の条件はアルゴリズム的に書くと</p>
            <p>
                <ul>
                    <li>すべてのマスを調べる</li>
                    <li>もしそのマスにいるのが相手の駒ならば</li>
                    <li>[c - 1][rank], [d - 1][rank], [e - 1][rank] のどれかに動くことができるなら False を返す。</li>
                    <li>すべてのマスについてクリア（相手はチェックできない）ならば True を返す。</li>
                </ul>
            </p>
            <p>となります。私のコードでは ran が rank の番号を、 fil が file の番号を表しています（もちろん０番スタートです）。条件の２つ目はいらないと思うかもしれませんが必ず入れてください。もし自分の駒も許した場合、当然 [e - 1][rank] には 4-1-1 で確認した通り行くことはできませんが、他の２マスにはいけます。そのせいで本来キャスリングできるのに False が返される恐れがあります。</p>
            <p>キングサイドについても全く同様に確認できます。こちらはキングの行先が [g - 1][rank] になることに注意してください。</p>
            <p>ここまできたら、王様とはいえ下手な動きは許されません。すべて False をリターンしてしまいましょう。</p>
            <p>これにて駒ごとの確認はすべて終わりです。長かったですね。最後に「piece の値がこれ以外の場合」をのぞいておきましょう。ポーンからキングまですべて場合分けしてんのに、まだ引っかからないやつはろくなもんじゃありません。</p>
        </section>

        <section id="s4-1-8">
            <h2>4-1-8　途中の駒の除外</h2>
            <p>キングまで終わったからって気を緩めてはいけません。さっきルークやビショップなど、放置したまんまでしょう。そいつらにケリをつけます。</p>
            <p>まず私のコードでは direction を定義していますね。文字通り駒の進む方向を表しています。この方向は [+1, +1], [-1, 0], ... といった具合に、「一歩先のマスに行くとき加える値」で表しています。白側からみて、左に行くのであれば [-1, 0], 右後ろへは [+1, -1] といったように。これは file, rank それぞれに対し、差をとって絶対値を１にする、つまり PosNeg(to - fr) とできるのです。</p>
            <p>その次は focused とありますね。これは「注目しているマス」を表しています。まだ to までたどり着いていないのに focused に駒があれば、入力された動きは途中で駒を飛び越えたことになりますから、 False をリターンします。それが次の while 文の中身となるわけです。先ほども申しました通り、次のマスへ行くには direction を各座標に加えればよいので、while の中では駒がないか確認し、 focused を動かしを繰り返していますね。</p>
            <p>while をすべてクリアしたら、もう True を返して問題ありません。お疲れ様でした。これにて駒の動きの判定は終了です。</p>
        </section>

        <section>
            <h2>次回予告</h2>
            <p>今回は motionjudge メソッドだけしかできませんでしたが、次回は実際に駒を動かします。一番面倒（のはず）な、この motionjudge を乗り越えた皆さんなら、この先の面倒な機能も問題なく実装できるでしょう。</p>
            <p><!--<a href="">-->次回　Stage 4-2　駒を動かす〜移動編〜<!--</a>--></p>
        </section>


    </main>

    <footer>
        <ul>
            <li>
                <a href="https://github.com/Saito-Saito-Saito" target="_blank">このページの作成者のGitHub</a>
            </li>
            <li>
                <a href="https://twitter.com/zsops_n" target="_blank">このページの作成者のTwitter</a>
            </li>
            <li>
                <a href="#">トップに戻る</a>
            </li>
        </ul>
    </footer>
</body>
</html>